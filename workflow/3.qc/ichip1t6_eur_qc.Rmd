---
title: "iChip 1 through 6 European QC"
author: "Translational Genomics Group"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output: github_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(readr)
library(dplyr)
library(knitr)
library(DT)
library(ggplot2)
library(readxl)
library(stringr)
```
## Set-up
This document is broken down into three parts. 
- Part 1 Identifies QC issues
- Part 2 Fixes and applies QC parameters
- Part 3 Re-Checks genotype data post QC Changes

## Source Data
IBD IChip, Runs 1-6, Illumina's TOP Allele Called, including GOLDR and removed BBC and aligned to HG19.

# Part 1 - Identify QC Issues
## Identification of individuals with discordant sex information WITH --geno and --maf filters
- Plink uses chrX data to determine sex (based on heterozygosity rates).  
- Default PLINK thresholds of .2 for Females and .8 for Males when assessing homozygosity rates, but use .4 and .8.  
- When the homozygosity rate is more than 0.4 but less than 0.8, the genotype data are inconclusive regarding the sex of an individual and these are marked in column 4 with a 0.
- maf and geno filter added with check-sex run
- PEDSEX=sex as recorded in pedfile (1=male, 2=female)  
- SNPSEX=sex as predicted based on genetic data (1=male, 2=female, 0=unknown)
- If needed, compare with GenomeStudio gender estimates to ID true problems
- We suggest running --check-sex once without parameters, eyeballing the distribution of F estimates (there should be a clear gap between a very tight male clump at the right side of the distribution and the females everywhere else), and then rerunning with parameters corresponding to the empirical gap.

```{bash}
plink \
--bfile ../2.estimate_ancestry/eur_cohort_split_ichip1t6 \
--geno 0.03 \
--maf 0.05 \
--check-sex .4 .8 \
--out temp_eur_cohort_split_ichip1t6
```

```{r}
"../2.estimate_ancestry/eur_cohort_split_ichip1t6.bim"
```

Using 596 chrX variants to check sex; 4 errors detected

```{r message=FALSE}
sexcheck <- read_table2(file = "IBDichip123456BBCTOP_unfilteredE3_HG19_common_snps_no_bbc_eur.sexcheck")
sexcheck %>%
  filter(STATUS == "PROBLEM") %>%
  datatable(caption = "List of Individuals with Sex Check Problems")
```

```{r}
sexcheck %>%
  filter(STATUS == "PROBLEM") %>%
  filter(PEDSEX != 0) %>%
  datatable(caption = "Sex Problems with a Reported Sex in Ped")
```

3 of 4 sex problems come from a reported PEDSEX of Female but an F > 0.4. 

```{r}
sexcheck %>%
  filter(STATUS == "PROBLEM") %>%
  filter(PEDSEX == 0) %>%
  datatable(caption = "Sex Probelms without Sex Recorded in Ped")
```

The remaining 1 problems come from samples without a reported PEDSEX, but are easily classified based on F.

```{r message=FALSE}
sexcheck %>%
  ggplot(aes(x = F)) +
  geom_density() +
  labs(title = "Heterozygoisty Rates for Samples Filtered with geno/maf included") 
```

Plotting F from check-sex based on chrX heterozygosity rates (F<0.4, M>0.8 expected). We can see that pretty normal distributions.

## Identification of individuals with elevated missing data rates or outlying heterozygosity rate
### Number of missing SNPS and Proportion of Missings SNPs per Individual
- no filters included here
- {output.imiss} for individuals (F_MISS will give proportion of missing SNPs per individual) 
- {output.lmiss} for snps (F_MISS will give proportion of samples missing per SNP)
- stricter missingness should apply for low MAF snps
- evaluate SNP missingness rates per cohort, genotyping batch, case-control status

```{bash}
plink \
--bfile ../2.estimate_ancestry/eur_cohort_split_ichip1t6 \
--missing \
--out eur_cohort_split_ichip1t6 
```

Total genotyping rate is 0.998878.

```{r message=FALSE, warning=FALSE}
lmiss <- read_table("IBDichip123456BBCTOP_unfilteredE3_HG19_common_snps_no_bbc_eur.lmiss")
lmiss %>%
  ggplot(aes(x = F_MISS)) +
  geom_density() +
  labs(title = "SNP Level Missingess")
```

Low missingness across iChip1-6

```{r message=FALSE, warning=FALSE}
imiss <- read_table("IBDichip123456BBCTOP_unfilteredE3_HG19_common_snps_no_bbc_eur.imiss")
imiss %>%
  ggplot(aes(x = F_MISS)) +
  geom_histogram(bins = 100) +
  labs(title = "Sample Level Missingess")
```

Small amount of missingness, likely batch related due to unique peaks, but still quite low. 

```{r}
imiss %>%
  filter(F_MISS >= 0.03) 
```
No samples with > 3% missingness. 

### Samples with outlying heterozygosity rates
- To calculate individual inbreeding F / heterozygosity With whole genome data, can be applied to pruned subset plink output includes:
  - O(HOM)    Observed number of homozygotes
  - E(HOM)    Expected number of homozygotes
  - N(NM)     Number of non-missing genotypes
  - F         F inbreeding coefficient estimate
- approx norm range: -0.2 to 0.2, mode around zero 
- Low heterozygosity (high F; positive value) may indicate inbreeding; 
- high heterozygosity (low F; negative value) may indicate contamination. 

```{bash}
plink \
--bfile IBDichip123456BBCTOP_unfilteredE3_HG19_common_snps_no_bbc_eur \
--het \
--out IBDichip123456BBCTOP_unfilteredE3_HG19_common_snps_no_bbc_eur
```

```{r message=FALSE}
het <- read_table("IBDichip123456BBCTOP_unfilteredE3_HG19_common_snps_no_bbc_eur.het") 
het 
```

```{r message=FALSE, warning=FALSE}
het <- het %>%
  mutate(obs_het_rate = (`N(NM)` - `O(HOM)`)/`E(HOM)`)
imiss_het <- left_join(imiss, het, by = "FID")

ggplot(imiss_het, aes(x = F_MISS, y = obs_het_rate)) +
  geom_point(color = densCols(log10(imiss_het$F_MISS), imiss_het$obs_het_rate)) +
  labs(x = "Proportion of missing genotypes", y = "Heterozygosity rate") +
  scale_x_log10(limits = c(0.001, 1), minor_breaks = c(0.01, 0.1)) +
  scale_y_continuous(limits = c(0, .5)) +
  geom_vline(xintercept = 0.03, color = "red") +
  geom_hline(yintercept = (mean(imiss_het$obs_het_rate)+(3*sd(imiss_het$obs_het_rate))), color = "red") +
  geom_hline(yintercept = (mean(imiss_het$obs_het_rate)-(3*sd(imiss_het$obs_het_rate))), color = "red")
```

### Identify het outliers

```{r}
imiss_het %>%
  filter(obs_het_rate >= (mean(imiss_het$obs_het_rate)+(4*sd(imiss_het$obs_het_rate))) |
           obs_het_rate <= (mean(imiss_het$obs_het_rate)-(4*sd(imiss_het$obs_het_rate)))) %>%
  datatable(caption = "Samples That Fail Het Check")

imiss_het %>%
  filter(obs_het_rate >= (mean(imiss_het$obs_het_rate)+(4*sd(imiss_het$obs_het_rate))) |
           obs_het_rate <= (mean(imiss_het$obs_het_rate)-(4*sd(imiss_het$obs_het_rate)))) %>%
  dplyr::select(FID, IID.x) %>%
  write_tsv("fail-het-outlier.txt", col_names = FALSE)
```
9 samples failed het check. They are overalll pretty good. Using 4 SD due to large sample. 


## Calculate Overall project MAF before Filtering

```{bash}
plink \
--bfile IBDichip123456BBCTOP_unfilteredE3_HG19_common_snps_no_bbc_eur \
--freq \
--out IBDichip123456BBCTOP_unfilteredE3_HG19_common_snps_no_bbc_eur
```

```{r message=FALSE, warning=FALSE}
maffreq <- read_table2("IBDichip123456BBCTOP_unfilteredE3_HG19_common_snps_no_bbc_eur.frq")
maffreq %>%
  ggplot(aes(x = MAF)) +
  geom_histogram(aes(y =..density..)) +
  geom_density(col=2) +
  labs(title = "Overall MAF Prior to Filtering")
```

## Identification of Duplicated or Related Individuals
- Prune dataset for temporary use of calculating cryptic relatedness and PCA as both work best under assumption of no LD among SNPs  
- Prior to calcuating identity by state, IBS, prune SNPs to only independent SNPs and remove regions with extended linkage disequiblibirum such as HLA region. The below removes snps within a 50kb window, with an r2 > .2 and variant count to shift the window at the end of each step of 5kb.   

```{bash}
plink \
--bfile IBDichip123456BBCTOP_unfilteredE3_HG19_common_snps_no_bbc_eur \
--exclude range original_data/highLDregions.txt \
--indep 50 5 1.8 \
--out IBDichip123456BBCTOP_unfilteredE3_HG19_common_snps_no_bbc_eur &>/dev/null
```

Pruning complete. 12368 variants excluded removed in high ld.  77285 of 121314  variants removed. I will keep only the prune.in snps for the subsequent analysis. 

- Can add --min 0.12 to identify minimum pihat for genome output to manage size of output dataset (will only output pihat >0.12)
- PIHAT 1.0 = monozygotic twins or known replicates 
- PIHAT 0.5 = 1st degree relatives: P-C, sibs
- PIHAT 0.25= 2nd degree relatives: half-sib, grandparents
- PIHAT 0.125= 3rd degree relatives: full cousins

```{bash}
plink \
--bfile IBDichip123456BBCTOP_unfilteredE3_HG19_common_snps_no_bbc_eur \
--extract IBDichip123456BBCTOP_unfilteredE3_HG19_common_snps_no_bbc_eur.prune.in \
--genome \
--min 0.12 \
--out IBDichip123456BBCTOP_unfilteredE3_HG19_common_snps_no_bbc_eur &>/dev/null
```

```{r warning=FALSE, message=FALSE}
genome <- read_table2("IBDichip123456BBCTOP_unfilteredE3_HG19_common_snps_no_bbc_eur.genome")

genome <- genome %>%
  mutate(PI_HAT = as.double(PI_HAT)) %>%
  mutate(color = if_else(PI_HAT <.15, "~3rd degree",
                         if_else(PI_HAT >=.15 & PI_HAT <.35, "~2nd degree",
                                 if_else(PI_HAT >= .35 & PI_HAT < .65, "~1st degree",
                                         if_else(PI_HAT > .65, "~Replicates or twins", "???")))))

genome %>%
  ggplot(aes(x = as.double(Z0), y = as.double(Z1), color = color)) +
  geom_point(alpha = 1/20) +
  guides(colour = guide_legend(override.aes = list(alpha = 1)))+
  labs(x = "Z0 the proportion of loci where the pair shares zero alleles", 
       y = "Z1 the proportion of loci where the pair shares one allele") 

```

We have a related cohort. The above plot is restricted to samples with a PI_HAT atleast 0.12. Samples can be represented more than once if multiple relations are found. 

```{r warning=FALSE, message=FALSE}
genome %>%
  ggplot(aes(x = as.double(PI_HAT), fill = color)) +
  geom_histogram(bins = 100) +
  labs(title = "Distribution of PI_HAT for Related Individuals >0.12", x = "PI_HAT", y = "Count (non-unique)")

```

```{r}
genome %>%
  filter(PI_HAT > 0.8)

genome %>%
  filter(PI_HAT > 0.8) %>%
  write_tsv("possible_duplicates.tsv")
```
133 matches. 

# Part 2 Apply QC Filters and Fix Errors
## Clean Sexes and remove samples and SNPs that fail heterozygoisty, genotyping, sex-checks and IBD >= 0.8/ 
### Clean Sexs
#### First update sex for subjects with PEDSEX == 0 and approriate F stat
If PED sex 0 and F < 0.4 updated PED to Female 2 
If PED sex 0 and F > 0.8 update PED to male 1 
All samples with previously un-assigned PED SEX assigned

```{r}
sexcheck %>%
  filter(PEDSEX == 0) %>%
  mutate(PEDSEX = ifelse(F < 0.4, 2,
                          ifelse(F > 0.8, 1, PEDSEX))) %>% 
  filter(PEDSEX != 0) %>%
  dplyr::select(FID, IID, PEDSEX)  %>%
  write_tsv("update-missing-sex.txt", col_names = FALSE)
  
sexcheck %>%
  filter(PEDSEX == 0) %>%
  mutate(PEDSEX = ifelse(F < 0.4, 2,
                          ifelse(F > 0.8, 1, PEDSEX))) %>% 
  filter(PEDSEX != 0) %>%
  dplyr::select(FID, IID, PEDSEX) %>%
  datatable(caption = "Subjects to Update Sex")

```

#### Create List of Subjects that Fail Sex Check After Update
```{r}
sexcheck %>%
  filter(PEDSEX == 1 & SNPSEX == 2 |
           PEDSEX == 2 & SNPSEX == 1 |
           PEDSEX == 2 & SNPSEX == 0 & F > 0.4 |
           PEDSEX == 1 & SNPSEX == 0 & F < 0.8) %>%
  dplyr::select(FID, IID) %>%
  write_tsv(path = "fail-updated-sex-check.txt", col_names = FALSE)
```
These are 3 female samples, that have out of range but quasi-reasonable F. I will flag for removal, but will discuss with Talin. 

#### Update Sex in PLINK
```{bash}
plink \
--bfile IBDichip123456BBCTOP_unfilteredE3_HG19_common_snps_no_bbc_eur \
--update-sex update-missing-sex.txt \
--remove fail-updated-sex-check.txt \
--make-bed \
--out IBDichip123456BBCTOP_unfilteredE3_HG19_common_snps_no_bbc_eur_sex_update
```
--update-sex: 1 people updated.
--Removed 3 samples. Went from  8297 to 8294 subjects. f

### Exclude Samples with IBD > 0.8
For the purposes of this QC, I want to identify all pairs of individuals with an IBD >=0.8 and then remove the individual in the pair with the lower genotyping rate. IN some cases, you will want to remove the individual with the lower genotyping rate dependent on the phenotype. The ID of the individuals with the lower genotype rate will be stored in ‘fail-IBD-QC.txt’ for subsequent removal.

```{bash}
perl original_data/run-IBD-QC-8.pl IBDichip123456BBCTOP_unfilteredE3_HG19_common_snps_no_bbc_eur
```

```{bash}
plink \
--bfile IBDichip123456BBCTOP_unfilteredE3_HG19_common_snps_no_bbc_eur_sex_update \
--remove fail-IBD-QC.txt \
--make-bed \
--out IBDichip123456BBCTOP_unfilteredE3_HG19_common_snps_no_bbc_eur_sex_update_clean1
```
8294 people to 8161 people 

### Failed SNPs missingness >97% and MAF 1%, and HWE 10^-6

```{bash}
plink \
--bfile IBDichip123456BBCTOP_unfilteredE3_HG19_common_snps_no_bbc_eur_sex_update_clean1 \
--geno 0.03 \
--maf 0.01 \
--hwe 0.000001 \
--make-bed \
--out IBDichip123456BBCTOP_unfilteredE3_HG19_common_snps_no_bbc_eur_sex_update_clean2 
```
521 variants removed due to missing genotype data (--geno).
574 variants removed due to Hardy-Weinberg exact test (--hwe)
18110 variants removed due to minor allele threshold(s)(--maf)


I am not applying a sample level genotype filter at this stage, becuase there may be some batch differences that I frist want to resolve at the SNP level rather than at the sample level. See below

### Failed Sample missingness >97%
```{bash}
plink \
--bfile IBDichip123456BBCTOP_unfilteredE3_HG19_common_snps_no_bbc_eur_sex_update_clean2 \
--mind 0.03 \
--make-bed \
--out IBDichip123456BBCTOP_unfilteredE3_HG19_common_snps_no_bbc_eur_sex_update_clean3 
```
No samples are removed at this stage and overall genotyping rate is quite good. Continuing on with this sub-set of SNPs. 

### Remove samples that fail het check
```{bash}
plink \
--bfile IBDichip123456BBCTOP_unfilteredE3_HG19_common_snps_no_bbc_eur_sex_update_clean3 \
--remove fail-het-outlier.txt \
--make-bed \
--out IBDichip123456BBCTOP_unfilteredE3_HG19_common_snps_no_bbc_eur_sex_update_clean4
```
8161 people to 8152 people


# Part 3 Re-Check File Post QC
## Recheck Missingess and Sex with Cleaned File

```{bash}
plink \
--bfile IBDichip123456BBCTOP_unfilteredE3_HG19_common_snps_no_bbc_eur_sex_update_clean4 \
--missing \
--out IBDichip123456BBCTOP_unfilteredE3_HG19_common_snps_no_bbc_eur_sex_update_clean4
```

```{r message=FALSE, warning=FALSE}
lmiss <- read_table("IBDichip123456BBCTOP_unfilteredE3_HG19_common_snps_no_bbc_eur_sex_update_clean4.lmiss")
lmiss %>%
  ggplot(aes(x = F_MISS)) +
  geom_histogram(bins = 10) +
  labs(title = "SNP Level Missingess after SNP level Filtering")
```

```{r message=FALSE, warning=FALSE}
imiss <- read_table("IBDichip123456BBCTOP_unfilteredE3_HG19_common_snps_no_bbc_eur_sex_update_clean4.imiss")
imiss %>%
  ggplot(aes(x = F_MISS)) +
  geom_histogram(bins = 100) +
  labs(title = "Sample Level Missingess after Sample Level Filtering")
```
Batch effect resolved. 

## Re-Check Hets
```{bash}
plink \
--bfile IBDichip123456BBCTOP_unfilteredE3_HG19_common_snps_no_bbc_eur_sex_update_clean4 \
--het \
--out IBDichip123456BBCTOP_unfilteredE3_HG19_common_snps_no_bbc_eur_sex_update_clean4
```

```{r message=FALSE, warning=FALSE}
imiss <- read_table("IBDichip123456BBCTOP_unfilteredE3_HG19_common_snps_no_bbc_eur_sex_update_clean4.imiss")
het <- read_table("IBDichip123456BBCTOP_unfilteredE3_HG19_common_snps_no_bbc_eur_sex_update_clean4.het") %>%
  mutate(obs_het_rate = (`N(NM)` - `O(HOM)`)/`E(HOM)`)
imiss_het <- left_join(imiss, het, by = "FID")

ggplot(imiss_het, aes(x = F_MISS, y = obs_het_rate)) +
  geom_point(color = densCols(log10(imiss_het$F_MISS), imiss_het$obs_het_rate)) +
  labs(x = "Proportion of missing genotypes", y = "Heterozygosity rate") +
  scale_x_log10(limits = c(0.001, 1), minor_breaks = c(0.01, 0.1)) +
  scale_y_continuous(limits = c(0, .5)) +
  geom_vline(xintercept = 0.03, color = "red") +
  geom_hline(yintercept = (mean(imiss_het$obs_het_rate)+(3*sd(imiss_het$obs_het_rate))), color = "red") +
  geom_hline(yintercept = (mean(imiss_het$obs_het_rate)-(3*sd(imiss_het$obs_het_rate))), color = "red")
```
Looks great. 

## Calculate Overall project MAF Adter Filtering

```{bash}
plink \
--bfile IBDichip123456BBCTOP_unfilteredE3_HG19_common_snps_no_bbc_eur_sex_update_clean4 \
--freq \
--out IBDichip123456BBCTOP_unfilteredE3_HG19_common_snps_no_bbc_eur_sex_update_clean4
```

```{r message=FALSE, warning=FALSE}
maffreq <- read_table2("IBDichip123456BBCTOP_unfilteredE3_HG19_common_snps_no_bbc_eur_sex_update_clean4.frq")
maffreq %>%
  ggplot(aes(x = MAF)) +
  geom_histogram(aes(y =..density..)) +
  geom_density(col=2) +
  labs(title = "Overall MAF After Filtering")
```

## Identification of Duplicated or Related Individuals
- Prune dataset for temporary use of calculating cryptic relatedness and PCA as both work best under assumption of no LD among SNPs  
- Prior to calcuating identity by state, IBS, prune SNPs to only independent SNPs and remove regions with extended linkage disequiblibirum such as HLA region. The below removes snps within a 50kb window, with an r2 > .2 and variant count to shift the window at the end of each step of 5kb.   

```{bash}
plink \
--bfile IBDichip123456BBCTOP_unfilteredE3_HG19_common_snps_no_bbc_eur_sex_update_clean4 \
--exclude original_data/highLDregions.txt \
--range \
--indep 50 5 1.8 \
--out IBDichip123456BBCTOP_unfilteredE3_HG19_common_snps_no_bbc_eur_sex_update_clean4 &>/dev/null
```


```{bash}
plink \
--bfile IBDichip123456BBCTOP_unfilteredE3_HG19_common_snps_no_bbc_eur_sex_update_clean4 \
--extract IBDichip123456BBCTOP_unfilteredE3_HG19_common_snps_no_bbc_eur_sex_update_clean4.prune.in \
--genome \
--min 0.12 \
--make-bed \
--out IBDichip123456BBCTOP_unfilteredE3_HG19_common_snps_no_bbc_eur_sex_update_clean4_pruned &>/dev/null
```

```{r warning=FALSE, message=FALSE}
genome <- read_table2("IBDichip123456BBCTOP_unfilteredE3_HG19_common_snps_no_bbc_eur_sex_update_clean4_pruned.genome")

genome <- genome %>%
  mutate(PI_HAT = as.double(PI_HAT)) %>%
  mutate(color = if_else(PI_HAT <.15, "~3rd degree",
                         if_else(PI_HAT >=.15 & PI_HAT <.35, "~2nd degree",
                                 if_else(PI_HAT >= .35 & PI_HAT < .65, "~1st degree",
                                         if_else(PI_HAT > .65, "~Replicates or twins", "???")))))

genome %>%
  ggplot(aes(x = as.double(Z0), y = as.double(Z1), color = color)) +
  geom_point(alpha = 1/20) +
  guides(colour = guide_legend(override.aes = list(alpha = 1)))+
  labs(x = "Z0 the proportion of loci where the pair shares zero alleles", 
       y = "Z1 the proportion of loci where the pair shares one allele") 

```

Replicates (purple) removed

```{r warning=FALSE, message=FALSE}
genome %>%
  ggplot(aes(x = as.double(PI_HAT), fill = color)) +
  geom_histogram(bins = 100) +
  labs(title = "Distribution of PI_HAT for Related Individuals >0.12", x = "PI_HAT", y = "Count (non-unique)")
```
